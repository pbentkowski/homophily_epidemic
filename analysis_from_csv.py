#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Doc string here, please...

Created on Fri Nov 18 16:25:32 2022

@author: Piotr Bentkowski - bentkowski.piotr@gmail.com
"""
import os
import glob
import json
import pickle
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib
# import matplotlib.ticker as mticker
matplotlib.use('agg')


def get_params():
    """
    Fetch the parameters from a Json file generated by the simulation
    code. These are used in computations.
    """
    simParam = glob.glob("simParams_*.json")
    if len(simParam) >= 1:
        fj = open(simParam[0],)
        simParams = json.load(fj)
        fj.close()
        desig = simParam[0].split("_")[-1].split(".")[0]
        return simParams, desig
    else:
        return None, None


def get_pSI():
    """Fetch the transmission between the disease compartments generated by
    the simulation code. These are used in plotting."""
    psi_f = glob.glob("pSI_big_*.pkl")
    if len(psi_f) >= 1:
        pSI = pickle.load(open(psi_f[0], 'rb'))
        pSI_ne = {}
        pSI_psi = {}
        for p in pSI:
            pSI_ne[p[0]] = p[1]
            pSI_psi[p[0]] = p[2]
        with open(psi_f[0][:-4] + '_ne.json', 'w', encoding='utf-8') as f:
            json.dump(pSI_ne, f, ensure_ascii=False, indent=4)
        with open(psi_f[0][:-4] + '_psi.json', 'w', encoding='utf-8') as f:
            json.dump(pSI_psi, f, ensure_ascii=False, indent=4)
        return pSI_psi, pSI_ne
    else:
        return None, None


def get_pSI_form_json():
    """Fetch the transmission between the disease compartments generated by
    the simulation code, but from a JSON file. These are used in plotting"""
    psi_f = glob.glob("pSI_Jbig_*.json")
    if len(psi_f) >= 1:
        fj = open(psi_f[0],)
        pSI = json.load(fj)
        pSI_ne = {}
        pSI_psi = {}
        for p in pSI:
            pSI_ne[p[0]] = p[1]
            pSI_psi[p[0]] = p[2]
        with open("pSI_big" + psi_f[0][8:-5] + '_ne.json', 'w', encoding='utf-8') as f:
            json.dump(pSI_ne, f, ensure_ascii=False, indent=4)
        with open("pSI_big" + psi_f[0][8:-5] + '_psi.json', 'w', encoding='utf-8') as f:
            json.dump(pSI_psi, f, ensure_ascii=False, indent=4)
        return pSI_psi, pSI_ne
    else:
        return None, None


def get_graphs_csv(dirr='.', search_term='*_gr.csv'):
    """Fetches the graphs stored in CSV files generated by the simulation code.

    Parameters
    ----------
    dirr : string with directory path, optional
        Directory where the CSV files with graphs are
    search_term : string with search pattern, optional
        Extension of the CSV files containing the graphs.

    Returns
    -------
    graphs : dictionary
        Dictionary were the keys are the asymmetries and values are lists of
        graphs.

    """
    gg_files = glob.glob(os.path.join(dirr, search_term))
    if len(gg_files) >= 1:
        asym_gg = {}
        for gg in gg_files:
            aa = gg.split("_")[-3]
            asym_gg[float(aa)] = aa
        idxs_gg = {}
        for gg in gg_files:
            ggi = gg.split("_")[-4].split("/")[-1]
            idxs_gg[int(ggi)] = ggi
        graphs = {}
        for idx in idxs_gg.keys():
            gga_dict = {}
            for aa in asym_gg.keys():
                strr = os.path.join(dirr,
                                    idxs_gg[idx] + "_" + asym_gg[aa] + "*"
                                    + "_gr.csv")
                ggn = []
                for f in np.sort(glob.glob(strr)):
                    # ggf = pickle.load(open(f, 'rb'))
                    ggn.append(np.loadtxt(f, comments='#',
                                          delimiter=',', dtype=int))
                gga_dict[aa] = ggn
            graphs[idx] = gga_dict
        return graphs
    else:
        return None


def sigle_graph_stat_from_file(ff, adh_node_numb):
    """
    Calculates the numbers of links inside a group and between groups
    in the graph.

    Parameters
    ----------
    ff : file path
        Path to a single `*_gr.csv` file containing the graph
    adh_node_numb : int
        Number of nodes that belong to the 'compliant to regulations' type
        of node.

    Returns
    -------
    int, int, int
        Number of links between nodes belonging to the same group

        number of links between nodes belonging to different groups

        total number of links in the graph.

    """
    grph = np.loadtxt(ff, comments='#', delimiter=',', dtype=int)
    inner_links = 0
    outer_links = 0
    for edge in grph:
        if edge[0] < adh_node_numb and edge[1] < adh_node_numb:
            inner_links += 1
        elif edge[0] < adh_node_numb and edge[1] >= adh_node_numb:
            outer_links += 1
        elif edge[0] >= adh_node_numb and edge[1] >= adh_node_numb:
            inner_links += 1
        elif edge[0] >= adh_node_numb and edge[1] < adh_node_numb:
            outer_links += 1
    return inner_links, outer_links, len(grph)


def sigle_graph_stat(grph, adh_node_numb):
    """
    Calculate the numbers of links inside a group and between groups
    in the graph. With graph represented as Numpy Array.

    Parameters
    ----------
    grph : Numpy Array
        A graph represented as two-collumn Numpy array with linked nodes. E.g.
        funtion `get_graphs_csv(…)` contains such graphs.
    adh_node_numb : int
        Number of nodes that belong to the 'compliant to regulations' type
        of node.

    Returns
    -------
    int, int, int
        Number of links between nodes belonging to the same group

        number of links between nodes belonging to different groups

        total number of links in the graph.

    """
    inner_links = 0
    outer_links = 0
    for edge in grph:
        if edge[0] < adh_node_numb and edge[1] < adh_node_numb:
            inner_links += 1
        elif edge[0] < adh_node_numb and edge[1] >= adh_node_numb:
            outer_links += 1
        elif edge[0] >= adh_node_numb and edge[1] >= adh_node_numb:
            inner_links += 1
        elif edge[0] >= adh_node_numb and edge[1] < adh_node_numb:
            outer_links += 1
    return inner_links, outer_links, len(grph)


def many_graph_stats(graphs, adh_node_numb):
    """
    Calculate the stats for the graphs in a data structure created by the
    funtion `get_graphs_csv(…)`.

    Parameters
    ----------
    graphs : special dictionary of graphs
        A dictionarty containing graphs in Numpy array format created by
        the function `get_graphs_csv(…)`.
    adh_node_numb : int
        Number of nodes that belong to the 'compliant to regulations' type
        of node.

    Returns
    -------
    final : dictionary
        A dictionary where the keys are the values of the asymetry parameter
        and the values arrays containing proportions of the number of
        inner-groub links to the number of the outer-group links.

    """
    indexes = sorted(graphs.keys())
    asymetries = sorted(graphs[0].keys())
    final = {}
    for asm in asymetries:
        res_list = []
        for indx in indexes:
            for grph in graphs[indx][asm]:
                inner, outer, total = sigle_graph_stat(grph, adh_node_numb)
                res_list.append((inner / outer))
        final[asm] = np.array(res_list)
    return final


def plot_many_graph_stats(graphs, simParams, pSI_psi, pSI_ne, ymin=0, ymax=10):
    """
    Take the data structure created by the function `get_graphs_csv(…)`,
    calculates the stats (the numbers of links inside a group and between
    groups in the graph for the graphs) and makes a plot of it.


    Parameters
    ----------
    graphs : special dictionary of graphs
        A dictionarty containing graphs in Numpy array format created by
        the function `get_graphs_csv(…)`.
    simParams : dictionary
        A dictionary loaded from a JSON file containing parametrisation of
        the model.
    pSI_psi : list
        The transmissions between the disease compartments
    pSI_ne : list
        The transmissions between the disease compartments.
    ymin : int, optional
        Lower bound for the plot's y-axis. The default is 0.
    ymax : int, optional
        Upper bound for the plot's y-axis. The default is 10.

    Returns
    -------
    None.

    """
    FS_ttl = 20
    FS = 18
    FS_tks = 16
    pSI = pSI_psi[0]
    eff_0 = pSI_ne[0][0]
    eff_1 = pSI_ne[0][1]
    cwd = os.getcwd()
    results = os.path.join(cwd, 'results')
    name = 'inner_2_outer_links.png'
    name = os.path.join(results, name)
    grf_stat = many_graph_stats(graphs, simParams['N_compliant'])
    asymetries = np.array(sorted(grf_stat.keys()))
    grf_mean = np.zeros(len(asymetries))
    grf_std = np.zeros(len(asymetries))
    for ii, asm in enumerate(asymetries):
        grf_mean[ii] = np.mean(grf_stat[asm])
        grf_std[ii] = np.std(grf_stat[asm])
    fig, ax = plt.subplots(1, 1, figsize=(14, 9))
    ax.fill_between(asymetries, grf_mean + grf_std, grf_mean - grf_std, alpha=0.2)
    ax.plot(asymetries, grf_mean, c='C0')
    ax.scatter(asymetries, grf_mean, c='C0')
    ax.set_title(
        r"pSI [{}, {}], [{}, {}]      $\eta=${} $\delta=$ {}".format(
            pSI[0][0], pSI[0][1], pSI[1][0], pSI[1][1], eff_0, eff_1
        ),
        fontsize=FS_ttl,
    )
    ax.set_ylabel("proportion of within-group links to out-of-group links",
                  fontsize=FS)
    ax.set_xlabel("asymmetry", fontsize=FS)
    ax.set_ylim((ymin, ymax))
    ax.grid(axis='y')
    ax.tick_params(axis="both", labelsize=FS_tks)
    plt.tight_layout()
    fig.savefig(name)
    # plt.show()
    plt.close(fig)


def print_params(simParams, pSI_psi, pSI_ne):
    """
    Creates a panel as a PNG image with all the model's params written on it.

    Parameters
    ----------
    simParams : dictionary
        A dictionary loaded from a JSON file containing parametrisation of
        the model.
    pSI_psi : list
        The transmissions between the disease compartments
    pSI_ne : list
        The transmissions between the disease compartments.

    Returns
    -------
    None.

    """
    plt.rcParams["font.family"] = "monospace"
    cwd = os.getcwd()
    results = os.path.join(cwd, 'results')
    if os.path.isdir(results) is False:
        os.mkdir(results)
    name = 'paramz.png'
    name = os.path.join(results, name)
    eff_0 = pSI_ne[0][0]
    eff_1 = pSI_ne[0][1]

    fig, ax = plt.subplots(1)

    ax.get_xaxis().set_visible(False)
    ax.get_yaxis().set_visible(False)
    for side in ['top', 'right', 'bottom', 'left']:
        ax.spines[side].set_visible(False)

    fig.text(0.1, 0.90, 'Type of graph       : ' + simParams['graph_type'])
    fig.text(0.1, 0.85, 'Nodes complient     : '
             + str(simParams['N_compliant']))
    fig.text(0.1, 0.80, 'Nodes non-complient : '
             + str(simParams['N_non_compl']))
    fig.text(0.1, 0.75, 'Mean degree         : '
             + str(simParams['mean_degree']))
    fig.text(0.1, 0.65, '# of complient init ifected : '
             + str(simParams['N_init_infected'][0]))
    fig.text(0.1, 0.60, '# of non-compl init ifected : '
             + str(simParams['N_init_infected'][1]))
    fig.text(0.1, 0.50, 'Basic infection p     : ' + str(simParams['p_nn']))
    fig.text(0.1, 0.45, 'Basic p(I -> R) compl : ' + str(simParams['pIR'][0]))
    fig.text(0.1, 0.40, 'Basic p(I -> R) non-c : ' + str(simParams['pIR'][0]))
    fig.text(0.1, 0.30, "$\\eta$ : " + str(eff_0))
    fig.text(0.1, 0.25, "$\\delta$ : " + str(eff_1))
    fig.text(0.1, 0.15, 'Run time: ' + simParams['start_time'])
    fig.savefig(name)
    plt.close(fig)


""


def aggregate_results_csv(simParams, pSI_ne, work_dir='.'):
    """
    Parameters
    ----------
    simParams : TYPE
        DESCRIPTION.
    work_dir : TYPE, optional
        DESCRIPTION. The default is '.'.

    Returns
    -------
    results : TYPE
        DESCRIPTION.

    """
    eff_0 = float(pSI_ne[0][0])
    eff_1 = float(pSI_ne[0][1])
    files = glob.glob(os.path.join(work_dir, "*_ev.csv"))
    if len(files) <= 0:
        return None
    results = []
    for df in files:
        indx = int(df.split("_")[-4].split('/')[-1])
        aa = float(df.split("_")[-3])
        file_desig = df.split("/")[-1][0:-7]
        evd = np.loadtxt(df, skiprows=1, delimiter=',', dtype=int)
        RCMP = evd[0:simParams['N_compliant']]
        RNC = evd[simParams['N_compliant']::]
        C2C = len(RCMP[(RCMP[:, 0] > 0) & (
            RCMP[:, 0] < simParams['N_compliant'])])
        C2N = len(RNC[(RNC[:, 0] > 0) & (
            RNC[:, 0] < simParams['N_compliant'])])
        N2C = len(RCMP[RCMP[:, 0] >= simParams['N_compliant']])
        N2N = len(RNC[RNC[:, 0] >= simParams['N_compliant']])
        results.append((indx, aa, eff_0, eff_1,
                        len(RCMP[RCMP[:, 2] > 0]), len(RNC[RNC[:, 2] > 0]),
                        C2C, C2N, N2C, N2N, file_desig))
    cols = ['run_indx', 'asymmetry', 'eta', 'delta',
            'R_compl', 'R_noncpl',
            'C2C', 'C2N', 'N2C', 'N2N', 'file_designator']
    results = pd.DataFrame(results, columns=cols)
    order = ['asymmetry', 'R_compl', 'R_noncpl', 'run_indx']
    results = results.sort_values(by=order)
    results = results.reset_index(drop=True)
    results.to_csv('results_table.csv', sep=',', index=False)
    return results


def plot_data(res, simParams, pSI_psi, pSI_ne,
              ymin_vax=0, ymax_vax=0.6, ymin_unvx=0, ymax_unvx=0.6):
    """


    Parameters
    ----------
    res : TYPE
        DESCRIPTION.
    simParams : TYPE
        DESCRIPTION.
    pSI_psi : TYPE
        DESCRIPTION.
    pSI_ne : TYPE
        DESCRIPTION.
    ymin_vax : TYPE, optional
        DESCRIPTION. The default is 0.
    ymax_vax : TYPE, optional
        DESCRIPTION. The default is 0.6.
    ymin_unvx : TYPE, optional
        DESCRIPTION. The default is 0.
    ymax_unvx : TYPE, optional
        DESCRIPTION. The default is 0.6.

    Returns
    -------
    None.

    """
    # res = pd.read_csv(csv_file, low_memory=False)
    asym = np.unique(res['asymmetry'])
    cwd = os.getcwd()
    results = os.path.join(cwd, 'results')
    if os.path.isdir(results) is False:
        os.mkdir(results)
    FS_ttl = 20
    FS = 18
    FS_tks = 16
    c_vaxed_dict = {'medianprops': dict(color='C0')}
    c_unvax_dict = {'medianprops': dict(color='C1')}

    name = 'R_fig_all.png'
    name = os.path.join(results, name)
    pSI = pSI_psi[0]
    eff_0 = pSI_ne[0][0]
    eff_1 = pSI_ne[0][1]
    stacked_dd_vac = []
    mean_dd_compl = []
    cols = []
    for aa in asym:
        r_vaxed = res[res['asymmetry'] == aa]['R_compl']
        normed_dd_compl = r_vaxed / simParams['N_compliant']
        cols.append(str(aa))
        # print(str(dd))
        stacked_dd_vac.append(normed_dd_compl)
        if len(r_vaxed) > 1:
            mean_dd_compl.append(np.mean(normed_dd_compl))
        else:
            mean_dd_compl.append(np.nan)
    mean_dd_compl = np.array(mean_dd_compl)
    fig, ax = plt.subplots(2, 1, figsize=(14, 13))
    ax[0].set_title(
        r"pSI [{}, {}], [{}, {}]      $\eta=${} $\delta=$ {}".format(
            "{0:.6g}".format(pSI[0][0]), "{0:.6g}".format(pSI[0][1]),
            "{0:.6g}".format(pSI[1][0]), "{0:.6g}".format(pSI[1][1]),
            eff_0, eff_1
        ),
        fontsize=FS_ttl,
    )
    ax[0].boxplot(stacked_dd_vac, tick_labels=cols, **c_vaxed_dict)
    ax[0].plot(np.arange(1, len(stacked_dd_vac) + 1), mean_dd_compl,
               c='C0', label="compliant")
    ax[0].set_ylim((ymin_vax, ymax_vax))
    ax[0].set_ylabel("fraction of recovered indv. in group", fontsize=FS)
    ax[0].grid(axis='y')
    ax[0].legend(fontsize=FS, frameon=False)
    # ax[0].set_xlabel("asymmetry", fontsize=FS)
    ax[0].tick_params(axis="both", labelsize=FS_tks)
    stacked_dd_unvac = []
    mean_dd_noncpl = []
    cols = []
    for aa in asym:
        r_noncpl = res[res['asymmetry'] == aa]['R_noncpl']
        normed_dd_noncpl = r_noncpl / simParams['N_non_compl']
        cols.append(str(aa))
        # print(str(dd))
        stacked_dd_unvac.append(normed_dd_noncpl)
        if len(r_noncpl) > 1:
            mean_dd_noncpl.append(np.mean(normed_dd_noncpl))
        else:
            mean_dd_noncpl.append(np.nan)
    mean_dd_compl = np.array(mean_dd_compl)
    ax[1].boxplot(stacked_dd_unvac, tick_labels=cols, **c_unvax_dict)
    ax[1].plot(np.arange(1, len(stacked_dd_unvac) + 1), mean_dd_noncpl,
               c='C1', label="non-compliant")
    ax[1].set_ylim((ymin_unvx, ymax_unvx))
    ax[1].set_ylabel("fraction of recovered indv. in group", fontsize=FS)
    ax[1].set_xlabel("asymmetry", fontsize=FS)
    ax[1].legend(fontsize=FS, frameon=False)
    ax[1].grid(axis='y')
    ax[1].tick_params(axis="both", labelsize=FS_tks)
    plt.tight_layout()
    fig.savefig(name)
    # plt.show()
    plt.close(fig)


def plot_data_points(res, simParams, pSI_psi, pSI_ne,
                     ymin_vax=0, ymax_vax=0.6, ymin_unvx=0, ymax_unvx=0.6):
    """


    Parameters
    ----------
    res : TYPE
        DESCRIPTION.
    simParams : TYPE
        DESCRIPTION.
    pSI_psi : TYPE
        DESCRIPTION.
    pSI_ne : TYPE
        DESCRIPTION.
    ymin_vax : TYPE, optional
        DESCRIPTION. The default is 0.
    ymax_vax : TYPE, optional
        DESCRIPTION. The default is 0.6.
    ymin_unvx : TYPE, optional
        DESCRIPTION. The default is 0.
    ymax_unvx : TYPE, optional
        DESCRIPTION. The default is 0.6.

    Returns
    -------
    None.

    """
    # res = pd.read_csv(csv_file, low_memory=False)
    asym = np.unique(res['asymmetry'])
    # results = os.getcwd()
    cwd = os.getcwd()
    results = os.path.join(cwd, 'results')
    if os.path.isdir(results) is False:
        os.mkdir(results)
    FS_ttl = 20
    FS = 18
    FS_tks = 16
    haze = 0.015
    name = 'R_fig_all_hazed.png'
    name = os.path.join(results, name)
    pSI = pSI_psi[0]
    eff_0 = pSI_ne[0][0]
    eff_1 = pSI_ne[0][1]
    stacked_dd_vac = []
    mean_dd_compl = []
    cols = []
    for aa in asym:
        r_vaxed = res[res['asymmetry'] == aa]['R_compl']
        normed_dd_compl = r_vaxed / simParams['N_compliant']
        cols.append(str(aa))
        stacked_dd_vac.append(normed_dd_compl)
        if len(r_vaxed) > 1:
            mean_dd_compl.append(np.mean(normed_dd_compl))
        else:
            mean_dd_compl.append(np.nan)
    mean_dd_compl = np.array(mean_dd_compl)
    fig, ax = plt.subplots(2, 1, figsize=(14, 13))
    ax[0].set_title(
        r"pSI [{}, {}], [{}, {}]      $\eta=${} $\delta=$ {}".format(
            "{0:.6g}".format(pSI[0][0]), "{0:.6g}".format(pSI[0][1]),
            "{0:.6g}".format(pSI[1][0]), "{0:.6g}".format(pSI[1][1]),
            eff_0, eff_1
        ),
        fontsize=FS_ttl,
    )
    for ii, aa in enumerate(asym):
        xx_asym = np.random.normal(aa, haze, size=len(stacked_dd_vac[ii]))
        ax[0].plot(xx_asym, stacked_dd_vac[ii], 'k.', alpha=0.2)
    ax[0].plot(asym, mean_dd_compl, c='C0', label="compliant", lw=3)
    ax[0].set_ylim((ymin_vax, ymax_vax))
    ax[0].set_ylabel("fraction of recovered indv. in group", fontsize=FS)
    ax[0].grid(axis='y')
    ax[0].legend(fontsize=FS, frameon=False)
    # ax[0].set_xlabel("asymmetry", fontsize=FS)
    ax[0].tick_params(axis="both", labelsize=FS_tks)
    ax[0].xaxis.set_ticks(asym)
    stacked_dd_unvac = []
    mean_dd_noncpl = []
    cols = []
    for aa in asym:
        r_noncpl = res[res['asymmetry'] == aa]['R_noncpl']
        normed_dd_noncpl = r_noncpl / simParams['N_non_compl']
        cols.append(str(aa))
        stacked_dd_unvac.append(normed_dd_noncpl)
        if len(r_noncpl) > 1:
            mean_dd_noncpl.append(np.mean(normed_dd_noncpl))
        else:
            mean_dd_noncpl.append(np.nan)
    mean_dd_compl = np.array(mean_dd_compl)
    for ii, aa in enumerate(asym):
        xx_asym = np.random.normal(aa, haze, size=len(stacked_dd_unvac[ii]))
        ax[1].plot(xx_asym, stacked_dd_unvac[ii], 'k.', alpha=0.2)
    ax[1].plot(asym, mean_dd_noncpl, c='C1', label="non-compliant", lw=3)
    ax[1].set_ylim((ymin_unvx, ymax_unvx))
    ax[1].set_ylabel("fraction of recovered indv. in group", fontsize=FS)
    ax[1].set_xlabel("asymmetry", fontsize=FS)
    ax[1].legend(fontsize=FS, frameon=False)
    ax[1].grid(axis='y')
    ax[1].tick_params(axis="both", labelsize=FS_tks)
    ax[1].xaxis.set_ticks(asym)
    plt.tight_layout()
    fig.savefig(name)
    # plt.show()
    plt.close(fig)


def plot_violin_R(res, simParams, pSI_psi, pSI_ne, y_min=0, y_max=0.6):
    """


    Parameters
    ----------
    res : TYPE
        DESCRIPTION.
    simParams : TYPE
        DESCRIPTION.
    pSI_psi : TYPE
        DESCRIPTION.
    pSI_ne : TYPE
        DESCRIPTION.
    ymin_vax : TYPE, optional
        DESCRIPTION. The default is 0.
    ymax_vax : TYPE, optional
        DESCRIPTION. The default is 0.6.
    ymin_unvx : TYPE, optional
        DESCRIPTION. The default is 0.
    ymax_unvx : TYPE, optional
        DESCRIPTION. The default is 0.6.

    Returns
    -------
    None.

    """
    asym = np.unique(res['asymmetry'])
    cwd = os.getcwd()
    results = os.path.join(cwd, 'results')
    if os.path.isdir(results) is False:
        os.mkdir(results)
    FS_ttl = 20
    FS = 18
    FS_tks = 16
    name = 'R_fig_all_violin.png'
    name = os.path.join(results, name)
    pSI = pSI_psi[0]
    eff_0 = pSI_ne[0][0]
    eff_1 = pSI_ne[0][1]
    xx = np.array(range(0, 10))
    # Prepping compliant data
    stacked_dd_vac = []
    mean_dd_compl = []
    cols = []
    for aa in asym:
        r_compl = res[res['asymmetry'] == aa]['R_compl']
        normed_dd_compl = r_compl / simParams['N_compliant']
        cols.append(str(aa))
        stacked_dd_vac.append(normed_dd_compl)
        if len(r_compl) > 1:
            mean_dd_compl.append(np.mean(normed_dd_compl))
        else:
            mean_dd_compl.append(np.nan)
    mean_dd_compl = np.array(mean_dd_compl)
    R_compl = pd.DataFrame(res['R_compl'].values / simParams['N_compliant'],
                           columns=['Fraction'])
    R_compl['Asymmetry'] = res['asymmetry'].values
    R_compl['Group'] = 'compliant'
    # Prepping non-compliant data
    stacked_dd_unvac = []
    mean_dd_noncpl = []
    cols = []
    for aa in asym:
        r_noncpl = res[res['asymmetry'] == aa]['R_noncpl']
        normed_dd_noncpl = r_noncpl / simParams['N_non_compl']
        cols.append(str(aa))
        stacked_dd_unvac.append(normed_dd_noncpl)
        if len(r_noncpl) > 1:
            mean_dd_noncpl.append(np.mean(normed_dd_noncpl))
        else:
            mean_dd_noncpl.append(np.nan)
    mean_dd_noncpl = np.array(mean_dd_noncpl)
    R_noncpl = pd.DataFrame(res['R_noncpl'].values / simParams['N_compliant'],
                            columns=['Fraction'])
    R_noncpl['Asymmetry'] = res['asymmetry'].values
    R_noncpl['Group'] = 'non-compliant'
    # Merge groups
    df_R = pd.concat([R_compl, R_noncpl])
    # Doing the plot
    fig, ax = plt.subplots(1, 1, figsize=(14, 8))
    ax.set_title(
        r"pSI [{}, {}], [{}, {}]      $\eta=${} $\delta=$ {}".format(
            "{0:.6g}".format(pSI[0][0]), "{0:.6g}".format(pSI[0][1]),
            "{0:.6g}".format(pSI[1][0]), "{0:.6g}".format(pSI[1][1]),
            eff_0, eff_1
        ),
        fontsize=FS_ttl,
    )
    sns.violinplot(x="Asymmetry", y="Fraction", hue="Group", data=df_R,
                   split=True, inner="quart", linewidth=1,
                   density_norm='width', ax=ax)
    ax.plot(xx, mean_dd_compl, linestyle='-', linewidth=2, color='C0')
    ax.plot(xx, mean_dd_noncpl, linestyle='-', linewidth=2, color='C1')
    # Customize the plot
    ax.set_xlabel("asymmetry", fontsize=FS)
    ax.set_ylabel("fraction of recovered indv. in group", fontsize=FS)
    # ax.xaxis.set_ticks(asym)
    ax.tick_params(axis="both", labelsize=FS_tks)
    ax.set_ylim((y_min, y_max))
    ax.grid(axis='y')
    ax.set_ylabel("fraction of recovered indv. in group", fontsize=FS)
    ax.legend(title="Group", loc="upper right", frameon=False,
              fontsize=FS, title_fontsize=FS)
    plt.tight_layout()
    fig.savefig(name)
    plt.close(fig)


def plot_transitions(res, pSI_psi, pSI_ne,
                     ymin_vax=0, ymax_vax=0.6, ymin_unvx=0, ymax_unvx=0.6):
    """


    Parameters
    ----------
    res : TYPE
        DESCRIPTION.
    pSI_psi : TYPE
        DESCRIPTION.
    pSI_ne : TYPE
        DESCRIPTION.
    ymin_vax : TYPE, optional
        DESCRIPTION. The default is 0.
    ymax_vax : TYPE, optional
        DESCRIPTION. The default is 0.6.
    ymin_unvx : TYPE, optional
        DESCRIPTION. The default is 0.
    ymax_unvx : TYPE, optional
        DESCRIPTION. The default is 0.6.

    Returns
    -------
    None.

    """
    # res = pd.read_csv(csv_file, low_memory=False)
    asym = np.unique(res['asymmetry'])
    cwd = os.getcwd()
    results = os.path.join(cwd, 'results')
    if os.path.isdir(results) is False:
        os.mkdir(results)
    FS_ttl = 20
    FS = 18
    FS_tks = 16
    c_vaxed_dict = {'medianprops': dict(color='C0')}
    c_unvax_dict = {'medianprops': dict(color='C1')}

    name = 'R_fig_transmissions.png'
    name = os.path.join(results, name)
    pSI = pSI_psi[0]
    eff_0 = pSI_ne[0][0]
    eff_1 = pSI_ne[0][1]
    stacked_dd_vac = []
    mean_dd_compl = []
    cols = []
    for aa in asym:
        r_vaxed = res[res['asymmetry'] == aa]['N2C']
        normed_dd_compl = r_vaxed
        cols.append(str(aa))
        # print(str(dd))
        stacked_dd_vac.append(normed_dd_compl)
        if len(r_vaxed) > 1:
            mean_dd_compl.append(np.mean(normed_dd_compl))
        else:
            mean_dd_compl.append(np.nan)
    mean_dd_compl = np.array(mean_dd_compl)
    fig, ax = plt.subplots(2, 1, figsize=(14, 13))
    ax[0].set_title(
        r"pSI [{}, {}], [{}, {}]      $\eta=${} $\delta=$ {}".format(
            "{0:.6g}".format(pSI[0][0]), "{0:.6g}".format(pSI[0][1]),
            "{0:.6g}".format(pSI[1][0]), "{0:.6g}".format(pSI[1][1]),
            eff_0, eff_1
        ),
        fontsize=FS_ttl,
    )
    ax[0].boxplot(stacked_dd_vac, tick_labels=cols, **c_vaxed_dict)
    ax[0].plot(np.arange(1, len(stacked_dd_vac) + 1), mean_dd_compl,
               c='C0', label="N2C")
    ax[0].set_ylim((ymin_vax, ymax_vax))
    ax[0].set_ylabel("number of infection events in group", fontsize=FS)
    ax[0].grid(axis='y')
    ax[0].legend(fontsize=FS, frameon=False)
    # ax[0].set_xlabel("asymmetry", fontsize=FS)
    ax[0].tick_params(axis="both", labelsize=FS_tks)
    stacked_dd_unvac = []
    mean_dd_noncpl = []
    cols = []
    for aa in asym:
        r_noncpl = res[res['asymmetry'] == aa]['N2N']
        normed_dd_noncpl = r_noncpl
        cols.append(str(aa))
        # print(str(dd))
        stacked_dd_unvac.append(normed_dd_noncpl)
        if len(r_noncpl) > 1:
            mean_dd_noncpl.append(np.mean(normed_dd_noncpl))
        else:
            mean_dd_noncpl.append(np.nan)
    mean_dd_compl = np.array(mean_dd_compl)
    ax[1].boxplot(stacked_dd_unvac, tick_labels=cols, **c_unvax_dict)
    ax[1].plot(np.arange(1, len(stacked_dd_unvac) + 1), mean_dd_noncpl,
               c='C1', label="N2N")
    ax[1].set_ylim((ymin_unvx, ymax_unvx))
    ax[1].set_ylabel("number of infection events in group", fontsize=FS)
    ax[1].set_xlabel("asymmetry", fontsize=FS)
    ax[1].legend(fontsize=FS, frameon=False)
    ax[1].grid(axis='y')
    ax[1].tick_params(axis="both", labelsize=FS_tks)
    plt.tight_layout()
    fig.savefig(name)
    # plt.show()
    plt.close(fig)


def plot_transmission_hist_one_asym(asym, res, bins=20, max_max=-1):
    """


    Parameters
    ----------
    asym : TYPE
        DESCRIPTION.
    res : TYPE
        DESCRIPTION.
    bins : TYPE, optional
        DESCRIPTION. The default is 20.
    max_max : TYPE, optional
        DESCRIPTION. The default is -1.

    Returns
    -------
    None.

    """
    # res = pd.read_csv(csv_file)
    res_as = res[res['asymmetry'] == asym]
    if len(res_as) < 1:
        print("ERROR in plot_transmission_hist_from_pd(): no results for",
              "asymmetry of", str(asym))
        return None
    cwd = os.getcwd()
    results = os.path.join(cwd, 'results')
    if os.path.isdir(results) is False:
        os.mkdir(results)
    f_name = os.path.join(results, "infecion_hist_" + str(asym) + ".png")
    if max_max <= 0:
        max_max = np.max((res_as['C2C'], res_as['C2N'],
                         res_as['N2C'], res_as['N2N']))
    fig, ax = plt.subplots(2, 1, figsize=(12, 8))
    ax[0].set_title("Asym = " + str(asym))
    ax[0].annotate('From compliant', xy=(0.45, 0.9), xycoords='axes fraction')
    ax[0].hist(res_as['C2C'], bins=bins, edgecolor='None',
               alpha=0.5, color='C0', label="compliant > compliant")
    ax[0].hist(res_as['C2N'], bins=bins, edgecolor='None',
               alpha=0.5, color='C1', label="compliant > non-compliant")
    ax[0].legend(frameon=False, loc='upper right')
    ax[0].set_xlim((0, max_max))
    ax[1].annotate('From NON-compliant', xy=(0.42, 0.9),
                   xycoords='axes fraction')
    ax[1].hist(res_as['N2C'], bins=bins, edgecolor='None',
               alpha=0.5, color='C0', label="non-compliant > compliant")
    ax[1].hist(res_as['N2N'], bins=bins, edgecolor='None',
               alpha=0.5, color='C1', label="non-compliant > non-compliant")
    ax[1].set_xlim((0, max_max))
    ax[1].legend(frameon=False, loc='upper right')
    ax[1].set_xlabel("number of infections")
    plt.tight_layout()
    fig.savefig(f_name)
    plt.close(fig)


def plot_transm_hist_all_asyms(res, bins=20):
    """


    Parameters
    ----------
    res : TYPE
        DESCRIPTION.
    bins : TYPE, optional
        DESCRIPTION. The default is 20.

    Returns
    -------
    None.

    """
    # res = pd.read_csv(csv_file, low_memory=False)
    asymetries = np.sort(np.unique(res['asymmetry']))
    # find max X to unify X-axis on plots
    tot_max = 0
    for asym in asymetries:
        max_max = np.max((res['C2C'], res['C2N'], res['N2C'], res['N2N']))
        if max_max > tot_max:
            tot_max = max_max
    for asym in asymetries:
        plot_transmission_hist_one_asym(asym, res, bins, tot_max)


def plot_RvsR_for_given_paramset(res, run_indx=None, ymin=0, ymax=400):
    """


    Parameters
    ----------
    res : TYPE
        DESCRIPTION.
    run_indx : TYPE, optional
        DESCRIPTION. The default is None.
    ymin : TYPE, optional
        DESCRIPTION. The default is 0.
    ymax : TYPE, optional
        DESCRIPTION. The default is 400.

    Returns
    -------
    None.

    """
    cwd = os.getcwd()
    results = os.path.join(cwd, 'results')
    if os.path.isdir(results) is False:
        os.mkdir(results)
    # res = pd.read_csv(result_file_csv)
    if run_indx is not None:
        res = res[res['run_indx'] == run_indx]
        desig = str(run_indx).zfill(5) + "_"
    else:
        desig = ""
    asyms = np.unique(res['asymmetry'])
    for aa in asyms:
        rr = res[res['asymmetry'] == aa]
        name_f = "results/R-R_" + desig + "asym_" \
            + str(np.round(aa, 4)) + ".png"
        fig, ax = plt.subplots(1, 1, figsize=(8, 8))
        ax.plot(np.linspace(ymin, ymax, 100), np.linspace(ymin, ymax, 100),
                '--', c='gray')
        ax.set_xlim((ymin, ymax))
        ax.set_ylim((ymin, ymax))
        ax.set_title("Asym = " + str(aa))
        ax = sns.scatterplot(x='R_compl', y='R_noncpl', data=rr)
        ax.grid()
        fig.tight_layout()
        fig.savefig(name_f)
        plt.close(fig)


def get_epi_trjec_one_asym(res, simParams, asym):
    """


    Parameters
    ----------
    res : TYPE
        DESCRIPTION.
    simParams : TYPE
        DESCRIPTION.
    asym : TYPE
        DESCRIPTION.

    Returns
    -------
    runz : TYPE
        DESCRIPTION.
    maxes : TYPE
        DESCRIPTION.
    asym : TYPE
        DESCRIPTION.
    tot_x_max : TYPE
        DESCRIPTION.
    tot_y_max : TYPE
        DESCRIPTION.

    """
    desig = list(res[res['asymmetry'] == asym]['file_designator'])
    tot_x_max = 0
    tot_y_max = 0
    runz = []
    # maxes = np.zeros((len(desig), 2))
    maxes = []
    for ii, df in enumerate(desig):
        try:
            evd = np.loadtxt(df + "_ev.csv", skiprows=1,
                             delimiter=',', dtype=int)
        except FileNotFoundError:
            continue
        RCMP = evd[0:simParams['N_compliant']]
        RNC = evd[simParams['N_compliant']::]
        vx = RCMP[RCMP[:, 2] > 0][:, 2]
        uvx = RNC[RNC[:, 2] > 0][:, 2]
        maxes.append([np.max(vx), np.max(uvx)])
        maxx = np.max([np.max(vx), np.max(uvx)])
        if tot_x_max < maxx:
            tot_x_max = maxx
        xx = np.zeros((maxx, 3), dtype=float)
        for tt in range(len(xx)):
            xx[tt, 0] = tt
            xx[tt, 1] = len(vx[vx <= tt]) / simParams['N_compliant']
            xx[tt, 2] = len(uvx[uvx <= tt]) / simParams['N_non_compl']
        maxy = np.max([np.max(xx[:, 1]), np.max(xx[:, 2])])
        if tot_y_max < maxy:
            tot_y_max = maxy
        runz.append(xx)
    maxes = np.array(maxes, dtype=int)
    return runz, maxes, asym, tot_x_max, tot_y_max


def get_epi_trjec_all(res, simParams):
    """


    Parameters
    ----------
    res : TYPE
        DESCRIPTION.
    simParams : TYPE
        DESCRIPTION.

    Returns
    -------
    all_runz : TYPE
        DESCRIPTION.
    all_maxes : TYPE
        DESCRIPTION.
    tot_tot_x_max : TYPE
        DESCRIPTION.
    tot_tot_y_max : TYPE
        DESCRIPTION.

    """
    asymmetry = np.unique(res['asymmetry'])
    all_runz = {}
    all_maxes = {}
    tot_tot_x_max = 0
    tot_tot_y_max = 0
    for asym in asymmetry:
        runz, maxes, asym, x_max, y_max = get_epi_trjec_one_asym(res,
                                                                 simParams,
                                                                 asym)
        all_runz[asym] = runz
        all_maxes[asym] = maxes
        if tot_tot_x_max < x_max:
            tot_tot_x_max = x_max
        if tot_tot_y_max < y_max:
            tot_tot_y_max = y_max
    return all_runz, all_maxes, tot_tot_x_max, tot_tot_y_max


def plot_epi_trjec_one_asym(runz, maxes, asym, tot_x_max, tot_y_max):
    """
    from analysis_from_csv import *
    all_runz, all_maxes, tot_tot_x_max, tot_tot_y_max = /
        get_epi_trjec_all(results, simParams)
    plot_epi_trjec_one_asym(all_runz[0.3], all_maxes[0.3], 0.3,
                            tot_tot_x_max, tot_tot_y_max)

    Parameters
    ----------
    runz : TYPE
        DESCRIPTION.
    maxes : TYPE
        DESCRIPTION.
    asym : TYPE
        DESCRIPTION.
    tot_x_max : TYPE
        DESCRIPTION.
    tot_y_max : TYPE
        DESCRIPTION.

    Returns
    -------
    None.

    """
    FS_ttl = 20
    FS = 18
    FS_tks = 16
    name_f = "results/R_trajec_" + "asym_" + str(np.round(asym, 4)) + ".png"
    fig, ax = plt.subplots(1, 1, figsize=(16, 12))
    for xx in runz:
        ax.plot(xx[:, 0], xx[:, 1], c='C0', lw=0.2)
        ax.plot(xx[:, 0], xx[:, 2], c='C1', lw=0.2)
    ax.plot(xx[:, 0], xx[:, 1], c='C0', lw=0.2, label="compliant")
    ax.plot(xx[:, 0], xx[:, 2], c='C1', lw=0.2, label="non-compliant")
    # ax.axhline(y=0.064,
    #            xmin=np.min(maxes[:, 0]) / tot_x_max,
    #            xmax=np.max(maxes[:, 0]) / tot_x_max,
    #            c='C0', lw=10)
    # ax.axhline(y=0.064,
    #            xmin=np.quantile(maxes[:, 0], 0.25) / tot_x_max,
    #            xmax=np.quantile(maxes[:, 0], 0.75) / tot_x_max,
    #            c='C0', lw=70)
    # ax.axhline(y=0.4,
    #            xmin=np.min(maxes[:, 1]) / tot_x_max,
    #            xmax=np.max(maxes[:, 1]) / tot_x_max,
    #            c='C1', lw=10)
    # ax.axhline(y=0.4,
    #            xmin=np.quantile(maxes[:, 1], 0.25) / tot_x_max,
    #            xmax=np.quantile(maxes[:, 1], 0.75) / tot_x_max,
    #            c='C1', lw=70)
    ax.set_xlim((0, tot_x_max))
    ax.set_ylim((0, tot_y_max))
    ax.set_title("Asym = " + str(asym), fontsize=FS_ttl)
    ax.set_xlabel("time (iterations)", fontsize=FS)
    ax.set_ylabel("fraction of recovered indv. in group", fontsize=FS)
    ax.tick_params(axis="both", labelsize=FS_tks)
    ax.legend(frameon=False, fontsize=FS)
    ax.grid()
    fig.tight_layout()
    fig.savefig(name_f)
    plt.close(fig)


def plot_all_epi_trjec(all_runz, all_maxes, tot_tot_x_max, tot_tot_y_max):
    """


    Parameters
    ----------
    all_runz : TYPE
        DESCRIPTION.
    all_maxes : TYPE
        DESCRIPTION.
    tot_tot_x_max : TYPE
        DESCRIPTION.
    tot_tot_y_max : TYPE
        DESCRIPTION.

    Returns
    -------
    None.

    """
    for asym in all_runz.keys():
        plot_epi_trjec_one_asym(all_runz[asym], all_maxes[asym], asym,
                                tot_tot_x_max, tot_tot_y_max)


def main():
    """ """
    lower_bnd_adhr = 0.0
    upper_bnd_adhr = 0.2
    lower_bnd_nona = 0.0
    upper_bnd_nona = 0.4
    max_transmit = 400

    simParams, des = get_params()
    pSI_psi, pSI_ne = get_pSI()
    if pSI_ne is None:
        pSI_psi, pSI_ne = get_pSI_form_json()

    results = aggregate_results_csv(simParams, pSI_ne)

    # csv_file = 'results_table.csv'
    # results = pd.read_csv(csv_file, low_memory=False)

    print_params(simParams, pSI_psi, pSI_ne)
    plot_violin_R(results, simParams, pSI_psi, pSI_ne,
                  lower_bnd_nona, upper_bnd_nona)
    plot_data(results, simParams, pSI_psi, pSI_ne,
              lower_bnd_adhr, upper_bnd_adhr, lower_bnd_nona, upper_bnd_nona)
    plot_data_points(results, simParams, pSI_psi, pSI_ne,
                     lower_bnd_adhr, upper_bnd_adhr,
                     lower_bnd_nona, upper_bnd_nona)
    plot_transm_hist_all_asyms(results, 20)
    plot_RvsR_for_given_paramset(results, None, 0, max_transmit)

    all_runz, all_maxes, tot_tot_x_max, tot_tot_y_max = get_epi_trjec_all(
        results, simParams)
    plot_all_epi_trjec(all_runz, all_maxes, tot_tot_x_max, tot_tot_y_max)


if __name__ == "__main__":
    main()
